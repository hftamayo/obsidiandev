

1. Idempotency → Prevents duplicate payments 
2. Pagination → Keeps your DB from dying 
3. Versioning → Lets you evolve APIs without breaking clients 
4. Rate limiting → Protects your service from abuse 
5. Error codes → Helps clients handle failures correctly 
6. Caching → Reduces load by 90% 
7. JWT security → Prevents leaking sensitive data 
8. N+1 queries → The difference between 10ms and 10s response time 
9. Docs → Stops the `how does this API work?` Slack messages 
10. Consistency → Choose the right tradeoff for your use case
11. If it’s real-time → WebSockets 
12. If it’s scale → Kafka 
13. If it’s simplicity → REST 
14. If it’s chaos → GraphQL 
15. If it’s AI → Python 
16. If it’s infra → Go 
17. If it’s logs → ElasticSearch 
18. If it’s low-latency → Redis 
19. If it’s high-availability → Postgres 
20. If it’s streaming → Flink 
21. If it’s low-level → C 
22. If it’s high-performance → C++ 
23. If it’s enterprise → Java